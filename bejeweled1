var cols = 7; //just change this nr if you want it to be bigger
var rows = cols;
var colors = ["#800014" /*red*/ , "#3F8000" /*green*/ , "#0354A6" /*blue*/ , "orange", "purple", "#CC7722" /*Ochre*/ ];


function setup() {
    createCanvas(cols*100+1, rows*100+1); // responsive canvas (+1 voor laatste lijn)
}

function draw() {
    background(255);
    //draw the playingfield
    playField = make2Darray(cols, rows);
    //safety mesure
    noLoop();
}


function make2Darray(cols, rows) {
    //create empty array
    var playField = new Array(cols);
    for (var i = 0; i < playField.length; i++) {
        playField[i] = new Array(rows);
    }
    //places random color values, coordinates and width in each spot; 
    //used to give the created rectangles the color.
    for (var i = 0; i < cols; i++) {
        for (var j = 0; j < rows; j++) {
            var randomColor = random(colors);
            x = i * 100;
            y = j * 100;
            playField[j][i] = { color: randomColor, position: { x: x, y: y}, width: 100};
            //fills block with exact same randomColor value as the element
            fill(playField[j][i].color);
            stroke(85);
            rect(x, y, 100, 100);
        }
    }
    return playField;
}

//replaces empty array elements
function replaceEmptySpots() {
    for (var i = 0; i < cols; i++) {
        for (var j = 0; j < rows; j++) {
            if(playField[j][i] == "") {  
                var randomColor = random(colors);
                x = i * 100;
                y = j * 100;
                playField[j][i] = { color: randomColor, position: { x: x, y: y}, width: 100};
                //fills block with exact same randomColor value as the element
                fill(playField[j][i].color);
                stroke(85);
                rect(x, y, 100, 100);
            }
        }
    }
    return playField;
}

//customly change block color on given positio in array playField
function updateBlockColor(j,i , strKleur) {
    x = i * 100;
    y = j * 100;
    playField[j][i] = { color: strKleur, position: { x: x, y: y}, width: 100};
    fill(playField[j][i].color);
    stroke(85);
    rect(x, y, 100, 100);
}

function widthArray(grid){
  return grid[0].length;
}

function heightArray(grid){
  return grid.length;
}

function horizontalChainAt(grid, position){
    x = position.x/100;
    y = position.y/100;
    let t = 1;
    let i = 1;
    while(x-i>-1 && grid[y][x-i].color == grid[y][x].color){
        i++;
        t++;
    }
    i = 1;
    while(x+i<cols && grid[y][x+i].color == grid[y][x].color){
        i++;
        t++;
    }
    return t;
}

function verticalChainAt(grid, position){
    x = position.x/100;
    y = position.y/100;
    let t = 1;
    let i = 1;
    while(y - i >= 0 && grid[y-i][x].color == grid[y][x].color){
        i++;
        t++;
    }
    i = 1;
    while(y + i < rows && grid[y+i][x].color == grid[y][x].color){
        i++;
        t++;
    }
    return t;
}

function swap(grid,p,q){ //verwisselt de kleuren van twee vakken binnen het playField
    xp = p.x/100;
    xq = q.x/100;
    yp = p.y/100;
    yq = q.y/100;
    let wisselkleur = grid[yp][xp].color;
    grid[yp][xp].color = grid[yq][xq].color;
    grid[yq][xq].color = wisselkleur;
    return playField;
}

function findElement(position) { //geeft de beginpositie van het aangeklikte vakje aan
    x = position.x - position.x%100;
    y = position.y - position.y%100;
    return element = {x: x, y: y};
}

function mousePressed(){
  
  if(mouseX<rows*100 && mouseY<cols*100){
    return mousePos = findElement({x: mouseX, y: mouseY});
    
  }
  console.log(mousePos);
}

function copyArray(grid){ //maakt een kopie van de geselecteerde grid
    copy = [];
    for (var i = 0; i < cols; i++) {
        copij = [];
        for (var j = 0; j < rows; j++) {
            copij.push(grid[j][i]);
        }
        copy.push(copij);
    }
    return copy;
}

function removeChains(grid){
  
  const result = {};
  const positions = [];

  for (let x = 0; x < rows; x++){
    let y = 0;
    while (y < cols){
        const n = verticalChainAt(grid, {x, y});
        if (n >2){
            for ( let i = 0; i !== n; i++){
                positions.push({x, y: y + i});
            }
        }
        y += n;
    }
}

  for (let y = 0; y < cols; y++){
      let x = 0;
      while (x < rows){
          const n = horizontalChainAt(grid, {x, y});
          if (n >2){
              for ( let i = 0; i !== n; i++){
                  positions.push({x: x + i, y});
              }
          }
          x += n;
      }
  }

 

  for(const position of positions){
      const {x,y} = position;
      const color = grid[y][x];
      result[color] = (result[color] || 0 ) + 1;;
  }

  for(const {x,y} of positions){
      grid[y][x] = "";
  }
  return result;
}

function removeChains(grid){
    var r = 0;
    var b = 0;
    var g = 0;
    var left = 0
    var right = 0
    var down = 0
    var up = 0
    for (i = 0; i < widthArray(grid); i++){
        for (j = 0; j < heightArray(grid); j++)
        {
            if (verticalChainAt(grid, {x: (i*100), y: (j*100)}) > 2) {
                grid[i][j].color = "black"
            }
            if (horizontalChainAt(grid, {x: (i*100), y: (j*100)}) > 2){
               grid[i][j].color = "black"
            }
        }
    }
    return playField;
}

function removeChains(grid){
    var r = 0;
    var b = 0;
    var g = 0;
    var left = 0
    var right = 0
    var down = 0
    var up = 0
    for (i = 0; i < widthArray(grid); i++){
        for (j = 0; j < heightArray(grid); j++)
        {
            if (verticalChainAt(grid, {x: (i*100), y: (j*100)}) > 2) {
                grid[i][j].color = "black"
            }
            if (horizontalChainAt(grid, {x: (i*100), y: (j*100)}) > 2){
               grid[i][j].color = "black"
            }
        }
    }
    return playField;
}

